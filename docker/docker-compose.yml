# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ DOCKER COMPOSE - STACK MLOps COMPLET
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 
# ğŸ“š OBJECTIF PÃ‰DAGOGIQUE
# Ce fichier orchestre l'ensemble des services nÃ©cessaires Ã  un systÃ¨me MLOps
# production-ready. Il illustre comment assembler :
#   - Une application ML (FastAPI)
#   - Une base de donnÃ©es (PostgreSQL)
#   - Un systÃ¨me de mÃ©triques (Prometheus)
#   - Des dashboards de monitoring (Grafana)
#
# ğŸ¯ CONCEPTS CLÃ‰S ABORDÃ‰S
# - Orchestration multi-conteneurs avec Docker Compose
# - Gestion des dÃ©pendances entre services (depends_on, healthcheck)
# - Configuration par variables d'environnement (.env)
# - Persistance des donnÃ©es avec volumes
# - Isolation rÃ©seau
# - Monitoring et observabilitÃ©
#
# ğŸ“– POUR ALLER PLUS LOIN
# - Documentation Docker Compose: https://docs.docker.com/compose/
# - Les 12 facteurs (12factor.net) pour applications cloud-native
# - Patterns de monitoring avec Prometheus/Grafana
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

version: '3.8'
# ğŸ’¡ Version du format Docker Compose
# La version 3.8 offre les fonctionnalitÃ©s modernes (healthchecks, depends_on avec conditions)
# tout en restant compatible avec la plupart des environnements de production

services:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 1ï¸âƒ£ SERVICE POSTGRESQL - Base de donnÃ©es relationnelle
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 
  # ğŸ¯ RÃ”LE : Stockage persistant des feedbacks utilisateurs et mÃ©tadonnÃ©es
  # 
  # ğŸ“š POURQUOI POSTGRESQL ?
  # - ACID compliance : garantit l'intÃ©gritÃ© des donnÃ©es (crucial pour les feedbacks)
  # - Support JSON natif : stockage flexible des mÃ©tadonnÃ©es de prÃ©dictions
  # - MaturitÃ© : base de donnÃ©es Ã©prouvÃ©e en production
  # - Image Alpine : version lÃ©gÃ¨re (-50% de taille vs standard)
  #
  # ğŸ”— INTERACTIONS
  # - ConsommÃ© par : cv_app (stockage feedbacks), grafana (dashboards SQL)
  # - DÃ©pendances : aucune (service de base)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  postgres:
    image: postgres:15-alpine
    # ğŸ’¡ Image officielle PostgreSQL 15 basÃ©e sur Alpine Linux
    # Alpine = distribution Linux ultra-lÃ©gÃ¨re (~5MB vs ~100MB pour Debian)
    # IdÃ©al pour conteneurs (dÃ©marrage rapide, moins de surface d'attaque)
    
    container_name: cv_postgres_${STUDENT_ID:-student10}
    # ğŸ’¡ Nom fixe du conteneur (facilite les logs et le debugging)
    # Sans cela, Docker gÃ©nÃ¨re un nom alÃ©atoire (ex: cv_v3_postgres_1)
    
    restart: unless-stopped
    # ğŸ”„ POLITIQUE DE REDÃ‰MARRAGE
    # - always : redÃ©marre mÃªme si arrÃªtÃ© manuellement (trop agressif)
    # - on-failure : uniquement en cas d'erreur (peut manquer des problÃ¨mes)
    # - unless-stopped : redÃ©marre sauf si arrÃªt manuel (RECOMMANDÃ‰ pour production)
    # - no : pas de redÃ©marrage automatique (dev uniquement)
    
    env_file:
      - ../.env
    # ğŸ“ Charge les variables d'environnement depuis .env (un niveau au-dessus)
    # Bonne pratique : sÃ©parer secrets (.env, gitignored) et configuration (docker-compose)
    
    environment:
      # ğŸ” CONFIGURATION BASE DE DONNÃ‰ES
      # Syntaxe : ${VARIABLE:-valeur_par_defaut}
      # Ordre de prioritÃ© : 1) .env, 2) valeur par dÃ©faut, 3) variable systÃ¨me
      
      POSTGRES_DB: ${DB_NAME:-cats_dogs_db}_${STUDENT_ID:-student10}
      # ğŸ’¡ Nom de la base crÃ©Ã©e automatiquement au premier dÃ©marrage
      # DÃ©faut : cats_dogs_db (si DB_NAME absent du .env)
      
      POSTGRES_USER: ${DB_USER:-catsdogs}
      # ğŸ’¡ Utilisateur propriÃ©taire de la base (droits admin sur cette DB)
      # âš ï¸ NE PAS utiliser 'postgres' (superuser) pour l'application (principe du moindre privilÃ¨ge)
      
      POSTGRES_PASSWORD: ${DB_PWD}
      # ğŸ”’ CRITIQUE : Mot de passe OBLIGATOIRE (pas de valeur par dÃ©faut)
      # Si absent â†’ erreur au dÃ©marrage (sÃ©curitÃ© by design)
    
    ports:
      - "${STUDENT_PORT_POSTGRES:-5433}:5432"
    # ğŸŒ MAPPING DE PORTS : hÃ´te:conteneur
    # - 5433 (hÃ´te) : port externe pour accÃ¨s local (Ã©vite conflit si PostgreSQL dÃ©jÃ  installÃ© sur 5432)
    # - 5432 (conteneur) : port interne standard PostgreSQL
    # ğŸ’¡ Les autres conteneurs utilisent postgres:5432 (rÃ©seau Docker interne)
    # ğŸ’¡ L'hÃ´te utilise localhost:5433 (pour DBeaver, psql, etc.)
    
    volumes:
      # ğŸ’¾ VOLUMES : Persistance et initialisation
      
      - postgres_data:/var/lib/postgresql/data #postgres_data_${STUDENT_ID:-student01}:/var/lib/postgresql/data
      # ğŸ“¦ Volume nommÃ© (gÃ©rÃ© par Docker) pour PERSISTANCE des donnÃ©es
      # /var/lib/postgresql/data = rÃ©pertoire standard des donnÃ©es PostgreSQL
      # âœ… Survit aux redÃ©marrages et suppressions de conteneur
      # âš ï¸ Ne pas supprimer ce volume sans backup !
      
      - ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql:ro
      # ğŸ¬ Script d'initialisation exÃ©cutÃ© AU PREMIER DÃ‰MARRAGE uniquement
      # /docker-entrypoint-initdb.d/ = rÃ©pertoire magique PostgreSQL
      # :ro = read-only (bonne pratique sÃ©curitÃ©)
      # ğŸ’¡ Utilise pour crÃ©er schÃ©ma, tables, index initiaux
      # âš ï¸ Ne se rÃ©exÃ©cute PAS si la base existe dÃ©jÃ  (cf. postgres_data)
    
    healthcheck:
      # ğŸ¥ HEALTHCHECK : VÃ©rification automatique de l'Ã©tat du service
      # Essentiel pour depends_on avec condition (voir cv_app ci-dessous)
      
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-catsdogs} -d ${DB_NAME:-cats_dogs_db}_${STUDENT_ID:-student10}"]
      # ğŸ©º Commande de test : pg_isready (utilitaire PostgreSQL)
      # VÃ©rifie que le serveur accepte les connexions
      # Format CMD-SHELL : exÃ©cute dans un shell (permet variables d'env)
      
      interval: 10s
      # â±ï¸ FrÃ©quence des vÃ©rifications : toutes les 10 secondes
      # Compromis : trop frÃ©quent = surcharge, trop rare = dÃ©tection lente
      
      timeout: 5s
      # â³ Timeout par vÃ©rification : abandon aprÃ¨s 5 secondes
      # PostgreSQL dÃ©marre gÃ©nÃ©ralement en <1s, mais peut Ãªtre plus long sous charge
      
      retries: 5
      # ğŸ” Nombre d'Ã©checs consÃ©cutifs avant de marquer "unhealthy"
      # 5 tentatives Ã— 10s = 50s max avant Ã©chec (raisonnable pour dÃ©marrage initial)
    
    # ğŸ“Š Ã‰TATS POSSIBLES DU HEALTHCHECK
    # - starting : vÃ©rifications en cours (retries non atteintes)
    # - healthy : test rÃ©ussi
    # - unhealthy : Ã©chec aprÃ¨s N retries
    # Visible via : docker ps (colonne STATUS)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 2ï¸âƒ£ SERVICE APPLICATION FASTAPI - CÅ“ur mÃ©tier ML
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  #
  # ğŸ¯ RÃ”LE : API de prÃ©diction + interface web + export mÃ©triques Prometheus
  #
  # ğŸ“š RESPONSABILITÃ‰S
  # - InfÃ©rence du modÃ¨le CNN (classification cats/dogs)
  # - Collecte des feedbacks utilisateurs â†’ PostgreSQL
  # - Exposition des mÃ©triques Prometheus (/metrics)
  # - Interface web (upload image + visualisation)
  #
  # ğŸ”— INTERACTIONS
  # - DÃ©pend de : postgres (stockage)
  # - ConsommÃ© par : prometheus (scraping mÃ©triques), utilisateurs (HTTP)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  cv_app:
    build:
      context: ..
      # ğŸ“‚ Contexte de build = rÃ©pertoire parent (racine du projet)
      # Permet d'accÃ©der Ã  src/, requirements/, models/ lors du build
      # Le Dockerfile peut alors COPY ../src â†’ /app/src
      
      dockerfile: docker/Dockerfile.app
      # ğŸ“„ Chemin relatif au contexte (..) du Dockerfile Ã  utiliser
      # SÃ©paration propre : configs Docker dans docker/, code dans src/
    
    container_name: cv_cats_dogs_app_${STUDENT_ID:-student10}
    restart: unless-stopped
    
    env_file:
      - ../.env
    
    environment:
      # ğŸ—„ï¸ CONFIGURATION BASE DE DONNÃ‰ES
      # Variables passÃ©es Ã  l'application FastAPI
      
      DB_HOST: postgres
      # ğŸŒ Hostname du service PostgreSQL
      # ğŸ’¡ Docker Compose crÃ©e un rÃ©seau interne avec rÃ©solution DNS automatique
      # "postgres" = nom du service â†’ rÃ©solu vers IP interne du conteneur
      # âš ï¸ NE PAS utiliser localhost (= conteneur lui-mÃªme) ni 127.0.0.1
      
      DB_PORT: 5432
      # ğŸ”Œ Port INTERNE (dans le rÃ©seau Docker)
      # DiffÃ©rent du port exposÃ© Ã  l'hÃ´te (5433)
      # Communication inter-conteneurs = rapide (pas de NAT)
      
      DB_NAME: ${DB_NAME:-cats_dogs_db}_${STUDENT_ID:-student10}
      DB_USER: ${DB_USER:-catsdogs}
      DB_PWD: ${DB_PWD}
      # ğŸ” MÃªme configuration que postgres (cohÃ©rence)
      
      DB_TABLE_MONITORING: ${DB_TABLE_MONITORING:-predictions_feedback}
      # ğŸ“Š Table de stockage des prÃ©dictions et feedbacks
      # CrÃ©Ã©e par init-db.sql
      
      API_TOKEN: ${API_TOKEN}
      # ğŸ”‘ Token d'authentification pour endpoints protÃ©gÃ©s
      # Exemple d'utilisation : POST /predict avec header Authorization: Bearer {token}
      
      ENABLE_PROMETHEUS: "true"
      # ğŸ“ˆ Active l'export de mÃ©triques Prometheus
      # Expose automatiquement l'endpoint /metrics
      # Format : Counter, Gauge, Histogram (voir prometheus_metrics.py)
      
      DISCORD_WEBHOOK_URL: ${DISCORD_WEBHOOK_URL:-}
      # ğŸ”” URL webhook pour notifications Discord (alerting)
      # Optionnel (valeur vide = notifications dÃ©sactivÃ©es)
      # Format : https://discord.com/api/webhooks/{id}/{token}

      STUDENT_ID: ${STUDENT_ID:-student10}
    
    ports:
      - "${STUDENT_PORT_API:-8000}:8000"
      # ğŸŒ Port de l'API FastAPI (standard FastAPI)
      # Accessible depuis : http://localhost:8000
      # ğŸ’¡ Un seul port car hÃ´te = conteneur (pas de conflit potentiel)
    
    volumes:
      # ğŸ“ MONTAGE DE VOLUMES : partage fichiers hÃ´te â†” conteneur
      
      - ../data:/app/data:ro
      # ğŸ“¸ Dataset d'images (cats/dogs)
      # :ro = read-only (l'app ne doit PAS modifier les donnÃ©es sources)
      # ğŸ’¡ Permet de tester avec de nouvelles images sans rebuild
      
      - ../models:/app/models:ro
      # ğŸ§  ModÃ¨le CNN prÃ©-entraÃ®nÃ© (.h5 ou .keras)
      # :ro = sÃ©curitÃ© (Ã©vite Ã©crasement accidentel du modÃ¨le)
      # ğŸ’¡ Pour mettre Ã  jour le modÃ¨le : remplacer fichier + redÃ©marrer conteneur
    
    depends_on:
      postgres:
        condition: service_healthy
      # â³ ORDRE DE DÃ‰MARRAGE AVEC VÃ‰RIFICATION
      # 
      # ğŸ“ Ã‰VOLUTION DES DEPENDS_ON
      # Version basique :
      #   depends_on: [postgres]  
      #   â†’ dÃ©marre APRÃˆS postgres, mais sans attendre qu'il soit prÃªt
      #   â†’ ProblÃ¨me : connexion Ã©choue si PostgreSQL encore en initialisation
      #
      # Version avancÃ©e (condition: service_healthy) :
      #   â†’ attend que le healthcheck de postgres soit "healthy"
      #   â†’ Garantit que la base accepte les connexions avant de dÃ©marrer l'app
      #
      # ğŸ’¡ Sans healthcheck, depends_on ne garantit PAS que le service est prÃªt !
      # Alternative : logique de retry dans l'app (moins propre)
    
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      # ğŸ©º VÃ©rifie que l'API rÃ©pond sur l'endpoint /health
      # curl -f : fail silently si HTTP status â‰  2xx/3xx
      # ğŸ’¡ NÃ©cessite un endpoint /health dans FastAPI (Ã  implÃ©menter)
      # Exemple rÃ©ponse : {"status": "healthy", "database": "connected"}
      
      interval: 30s
      # â±ï¸ 30s entre chaque check (moins frÃ©quent que postgres car app plus stable)
      
      timeout: 10s
      # â³ Timeout augmentÃ© (infÃ©rence CNN peut prendre quelques secondes)
      
      retries: 3
      # ğŸ” 3 Ã©checs = unhealthy (3Ã—30s = 90s max)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 3ï¸âƒ£ SERVICE PROMETHEUS - SystÃ¨me de mÃ©triques time-series
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  #
  # ğŸ¯ RÃ”LE : Collecte, stockage et requÃªtage des mÃ©triques applicatives
  #
  # ğŸ“š PROMETHEUS EN BREF
  # - Pull-based : scrape les endpoints /metrics (vs push comme StatsD)
  # - Time-series DB : optimisÃ© pour donnÃ©es horodatÃ©es (mÃ©trique + timestamp)
  # - PromQL : langage de requÃªtage puissant pour alertes et graphiques
  # - Service discovery : dÃ©tecte automatiquement les targets Ã  scraper
  #
  # ğŸ”— INTERACTIONS
  # - Scrape : cv_app:8000/metrics (toutes les 15s par dÃ©faut, cf. prometheus.yml)
  # - ConsommÃ© par : grafana (datasource), utilisateurs (UI web sur :9090)
  #
  # ğŸ“Š MÃ‰TRIQUES COLLECTÃ‰ES (exemples)
  # - http_requests_total : nombre de requÃªtes API
  # - prediction_duration_seconds : latence d'infÃ©rence
  # - model_accuracy : prÃ©cision du modÃ¨le
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  prometheus:
    image: prom/prometheus:latest
    # ğŸ“¦ Image officielle Prometheus (maintenue par la CNCF)
    # :latest = derniÃ¨re version stable (alternative : tag spÃ©cifique pour prod)
    
    container_name: cv_prometheus_${STUDENT_ID:-student10}
    restart: unless-stopped
    
    command:
      # ğŸš€ Arguments passÃ©s au dÃ©marrage de Prometheus
      # Overwrite la commande par dÃ©faut de l'image
      
      - '--config.file=/etc/prometheus/prometheus.yml'
      # ğŸ“„ Fichier de configuration principal
      # DÃ©finit : targets Ã  scraper, alerting rules, storage settings
      
      - '--storage.tsdb.path=/prometheus'
      # ğŸ’¾ RÃ©pertoire de stockage des time-series
      # TSDB = Time Series Database (format propriÃ©taire Prometheus)
      # ğŸ’¡ MontÃ© sur volume nommÃ© pour persistance
      
      - '--web.enable-lifecycle'
      # ğŸ”„ Active l'endpoint HTTP POST /-/reload pour rechargement config
      # Utile pour mettre Ã  jour prometheus.yml sans redÃ©marrage
      # Exemple : curl -X POST http://localhost:9090/-/reload
    
    ports:
      - "${STUDENT_PORT_PROMETHEUS:-9100}:9090"
      # ğŸŒ Interface web Prometheus
      # Accessible : http://localhost:9090
      # FonctionnalitÃ©s :
      #   - /graph : requÃªtes PromQL et graphiques ad-hoc
      #   - /targets : statut des endpoints scrapÃ©s
      #   - /alerts : rÃ¨gles d'alerte actives
      #   - /config : configuration courante
    
    volumes:
      - ../monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      # âš™ï¸ Configuration principale (read-only)
      # Contient : scrape_configs, alerting_rules, etc.
      # ğŸ’¡ Modifiable Ã  chaud avec --web.enable-lifecycle
      
      - ../monitoring/prometheus/rules:/etc/prometheus/rules:ro
      # ğŸš¨ RÃ¨gles d'alerte (fichiers .yml)
      # Exemple : alert si latence > 2s pendant 5min
      # Format : groupes de rÃ¨gles avec expressions PromQL
      
      - prometheus_data:/prometheus #prometheus_data_${STUDENT_ID:-student01}:/prometheus
      # ğŸ’¾ Volume nommÃ© pour TSDB (persistance des mÃ©triques)
      # Taille : croÃ®t linÃ©airement avec le nombre de mÃ©triques et la rÃ©tention
      # âš ï¸ DÃ©finir une politique de rÃ©tention (dÃ©faut : 15 jours)
      # Configuration : --storage.tsdb.retention.time=30d
    
    depends_on:
      - cv_app
      # â³ DÃ©marre APRÃˆS cv_app
      # ğŸ’¡ Pas de condition: service_healthy car Prometheus tolÃ¨re les targets down
      # Il marquera simplement cv_app comme "down" jusqu'Ã  ce qu'elle rÃ©ponde

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # 4ï¸âƒ£ SERVICE GRAFANA - Plateforme de visualisation et alerting
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  #
  # ğŸ¯ RÃ”LE : Dashboards interactifs + alerting avancÃ© + notification Discord
  #
  # ğŸ“š GRAFANA EN BREF
  # - Multi-datasources : Prometheus, PostgreSQL, Elasticsearch, etc.
  # - Provisioning : configuration as code (dashboards, datasources, alertes)
  # - Unified Alerting : systÃ¨me d'alerte moderne (remplace legacy alerting)
  # - Templating : dashboards dynamiques avec variables
  #
  # ğŸ”— INTERACTIONS
  # - Datasources : prometheus (mÃ©triques), postgres (donnÃ©es mÃ©tier)
  # - Notifications : Discord webhook (alertes)
  # - ConsommÃ© par : utilisateurs (dashboards web sur :3000)
  #
  # ğŸ¨ DASHBOARDS PROVISIONNÃ‰S
  # - cv_dashboard.json : mÃ©triques ML (accuracy, latence, volume prÃ©dictions)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  grafana:
    image: grafana/grafana:latest
    # ğŸ“¦ Image officielle Grafana Labs
    
    container_name: cv_grafana_${STUDENT_ID:-student10}
    restart: unless-stopped
    
    environment:
      # ğŸ” CREDENTIALS ADMIN (premiÃ¨re connexion)
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD:-admin}
      # âš ï¸ CHANGER EN PRODUCTION ! Valeurs par dÃ©faut = risque sÃ©curitÃ©
      # StockÃ©es en variables d'env pour rotation facile
      
      GF_PATHS_PROVISIONING: /etc/grafana/provisioning
      # ğŸ“ RÃ©pertoire de provisioning automatique
      # Grafana scanne ce dossier au dÃ©marrage et applique les configs
      # Structure : datasources/, dashboards/, notifiers/, alerting/
      
      GF_UNIFIED_ALERTING_ENABLED: "true"
      # ğŸ”” Active le nouveau systÃ¨me d'alerte (Grafana 8+)
      # FonctionnalitÃ©s :
      #   - Multi-datasource alerting (pas que Prometheus)
      #   - Regroupement d'alertes (notification groups)
      #   - Silences et inhibitions avancÃ©es
      
      GF_ALERTING_ENABLED: "false"
      # ğŸš« DÃ©sactive l'ancien systÃ¨me (legacy alerting)
      # âš ï¸ Les deux systÃ¨mes sont mutuellement exclusifs
      # Unified = moderne, legacy = dÃ©prÃ©ciÃ© depuis Grafana 9

      GF_SERVER_ROOT_URL: "http://${VPS_HOST:-localhost}:${STUDENT_PORT_GRAFANA:-3000}"
      DB_NAME: ${DB_NAME:-cats_dogs_db}
      DB_USER: ${DB_USER:-catsdogs}
      DB_PWD: ${DB_PWD}
      STUDENT_ID: ${STUDENT_ID:-student10}
    
    ports:
      - "${STUDENT_PORT_GRAFANA:-3000}:3000"
      # ğŸŒ Interface web Grafana
      # Accessible : http://localhost:3000
      # Login : admin / admin (premiÃ¨re fois)
    
    volumes:
      # ğŸ“‚ PROVISIONING : Configuration automatique au dÃ©marrage
      # ğŸ’¡ Alternative au clic-clic dans l'UI (Infrastructure as Code)
      
      - ../monitoring/grafana/provisioning/datasources:/etc/grafana/provisioning/datasources:ro
      # ğŸ”Œ Datasources (Prometheus, PostgreSQL)
      # Fichier .yml dÃ©finit : type, URL, accÃ¨s, credentials
      # Exemple : prometheus datasource â†’ http://prometheus:9090
      
      - ../monitoring/grafana/provisioning/dashboards/dashboards.yml:/etc/grafana/provisioning/dashboards/dashboards.yml:ro
      # ğŸ“‹ Configuration des dashboards (mÃ©tadonnÃ©es)
      # Pointe vers le rÃ©pertoire contenant les fichiers .json
      
      - ../monitoring/grafana/provisioning/dashboards/cv_dashboard.json:/var/lib/grafana/dashboards/cv_dashboard.json:ro
      # ğŸ“Š Dashboard principal (dÃ©finition JSON complÃ¨te)
      # Contient : panels, queries PromQL, seuils d'alerte, layout
      # ğŸ’¡ Exportable depuis l'UI Grafana (Share â†’ Export â†’ Save to file)
      
      - ../monitoring/grafana/provisioning/alerting:/etc/grafana/provisioning/alerting:ro
      # ğŸš¨ Configuration Unified Alerting
      # Contient : rÃ¨gles d'alerte, contact points (Discord), notification policies
      # Format : fichiers .yml avec dÃ©finition des alertes
      
      - grafana_data:/var/lib/grafana #grafana_data_${STUDENT_ID:-student01}:/var/lib/grafana
      # ğŸ’¾ Volume nommÃ© pour persistance
      # Contient : sessions utilisateurs, annotations, configurations modifiÃ©es via UI
      # ğŸ’¡ Les dashboards provisionnÃ©s sont read-only (modifs UI perdues au redÃ©marrage)
    
    depends_on:
      postgres:
        condition: service_healthy
      # â³ Attend PostgreSQL (datasource SQL pour dashboards mÃ©tier)
      
      prometheus:
        condition: service_started
      # â³ Attend Prometheus (datasource principal pour mÃ©triques)
      # ğŸ’¡ service_started suffit (pas de healthcheck pour Prometheus ici)
      # Grafana tolÃ¨re les datasources temporairement inaccessibles

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¦ VOLUMES - Persistance des donnÃ©es
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# ğŸ“ VOLUMES NOMMÃ‰S vs BIND MOUNTS
#
# VOLUMES NOMMÃ‰S (utilisÃ©s ici) :
#   Syntaxe : volume_name:/chemin/conteneur
#   GÃ©rÃ© par : Docker (stockage dans /var/lib/docker/volumes/)
#   Avantages :
#     âœ… Portable (indÃ©pendant du systÃ¨me de fichiers hÃ´te)
#     âœ… Performance (optimisÃ© par Docker)
#     âœ… Backup facile (docker volume create --name=backup)
#     âœ… Partage entre conteneurs
#   Usages : bases de donnÃ©es, caches, logs
#
# BIND MOUNTS (utilisÃ©s pour config) :
#   Syntaxe : ./chemin/hÃ´te:/chemin/conteneur
#   GÃ©rÃ© par : systÃ¨me de fichiers hÃ´te
#   Avantages :
#     âœ… Ã‰dition directe des fichiers (pas de docker cp)
#     âœ… Version control (Git)
#     âœ… Transparence (chemin explicite)
#   Usages : code source, configs, fichiers statiques
#
# ğŸ’¡ RÃˆGLE D'OR : DonnÃ©es â†’ volumes nommÃ©s, Config â†’ bind mounts
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
volumes:
  postgres_data: #postgres_data_${STUDENT_ID:-student01}:
    # ğŸ’¾ DonnÃ©es PostgreSQL (tables, index, WAL logs)
    # Taille : varie selon volume de feedbacks (ex: 100MB pour 100k prÃ©dictions)
    # Backup : docker run --rm -v postgres_data:/data -v $(pwd):/backup alpine tar czf /backup/postgres.tar.gz /data
    
  prometheus_data: #prometheus_data_${STUDENT_ID:-student01}:
    # ğŸ“ˆ Time-series Prometheus (chunks compressÃ©s)
    # Taille : dÃ©pend de (nombre_mÃ©triques Ã— scrape_interval Ã— retention)
    # Exemple : 100 mÃ©triques Ã— 15s scrape Ã— 30j retention â‰ˆ 500MB
    # Compression : ~10x (Prometheus stocke efficacement les sÃ©ries temporelles)
    
  grafana_data: #grafana_data_${STUDENT_ID:-student01}:
    # ğŸ¨ Configurations Grafana (sessions, annotations, prefs utilisateur)
    # Taille : gÃ©nÃ©ralement <100MB (lÃ©ger)
    # âš ï¸ Ne contient PAS les dashboards provisionnÃ©s (read-only dans provisioning/)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ RÃ‰SEAU - Isolation et communication inter-conteneurs
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# ğŸ“ RÃ‰SEAUX DOCKER COMPOSE
#
# Par dÃ©faut, Docker Compose crÃ©e un rÃ©seau bridge automatique :
#   - Nom : {projet}_default (ex: cv_v3_default)
#   - DNS automatique : rÃ©solution par nom de service (ex: postgres, cv_app)
#   - Isolation : conteneurs de projets diffÃ©rents ne se voient pas
#
# Configuration custom (ci-dessous) :
#   - Nom explicite : cv_mlops_network (plus lisible dans docker network ls)
#   - MÃªme comportement que default mais prÃ©visible
#
# ğŸ’¡ COMMUNICATION INTER-CONTENEURS
#   cv_app â†’ postgres:5432 âœ… (rÃ©seau interne, rapide)
#   cv_app â†’ localhost:5433 âŒ (localhost = le conteneur lui-mÃªme)
#   grafana â†’ prometheus:9090 âœ…
#   prometheus â†’ cv_app:8000/metrics âœ…
#
# ğŸ”’ SÃ‰CURITÃ‰
#   - Conteneurs isolÃ©s de l'hÃ´te (sauf ports exposÃ©s)
#   - Pas d'accÃ¨s internet par dÃ©faut (sauf si image pull ou apt-get)
#   - Firewall : seuls les ports mappÃ©s (8000, 3000, etc.) sont accessibles depuis l'hÃ´te
#
# ğŸ“Š DÃ‰BOGAGE RÃ‰SEAU
#   docker network inspect cv_mlops_network  # voir IPs et conteneurs connectÃ©s
#   docker exec cv_app ping prometheus       # tester connectivitÃ©
#   docker logs cv_app | grep "connection"   # chercher erreurs connexion
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
networks:
  default:
    name: cv_mlops_network_${STUDENT_ID:-student10}
    # ğŸ·ï¸ Nom custom du rÃ©seau (remplace {projet}_default)
    # Avantages :
    #   - LisibilitÃ© (docker network ls)
    #   - StabilitÃ© (pas de changement si rÃ©pertoire renommÃ©)
    #   - Documentation (nom explicite = intention claire)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ COMMANDES UTILES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# DÃ‰MARRAGE
#   docker compose up -d                    # DÃ©marre tous les services en arriÃ¨re-plan
#   docker compose up -d cv_app prometheus  # DÃ©marre uniquement certains services
#   docker compose up --build               # Rebuild les images avant dÃ©marrage
#
# MONITORING
#   docker compose ps                       # Liste les conteneurs (status, ports, health)
#   docker compose logs -f cv_app           # Suit les logs en temps rÃ©el
#   docker compose logs --tail=100 postgres # 100 derniÃ¨res lignes
#
# GESTION
#   docker compose stop                     # ArrÃªte sans supprimer
#   docker compose restart cv_app           # RedÃ©marre un service
#   docker compose down                     # ArrÃªte ET supprime conteneurs/rÃ©seau
#   docker compose down -v                  # + supprime volumes (âš ï¸ perte donnÃ©es)
#
# DÃ‰BOGAGE
#   docker compose exec cv_app bash         # Shell interactif dans le conteneur
#   docker compose exec postgres psql -U catsdogs -d cats_dogs_db  # Client PostgreSQL
#   docker compose top                      # Processus en cours dans chaque conteneur
#
# NETTOYAGE
#   docker compose down --rmi all           # Supprime aussi les images
#   docker system prune -a --volumes        # âš ï¸ Nettoie TOUT Docker (pas que ce projet)